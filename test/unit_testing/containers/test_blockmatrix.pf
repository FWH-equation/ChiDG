!
!   TODO: Tests for Chimera Initialization!!
!
!




!--------------------------------------------------------------------------------
!       Test STORE procedure for storing derivative information
!--------------------------------------------------------------------------------
! Test storage of derivatives in blockmatrix when using one equation
@Test
subroutine test_blockmatrix__store_1eq_8terms()
    use pfunit_mod
    use mod_kinds,                  only: rk,ik
    use mod_constants,              only: ZERO, ONE, TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT
    use type_chidg,                 only: chidg_t
    use type_mesh,                  only: mesh_t
    use type_point,                 only: point_t
    use type_blockmatrix,           only: blockmatrix_t
    use type_domain_connectivity,   only: domain_connectivity_t
    use type_face_info,             only: face_info_t
    use type_seed,                  only: seed_t
    use mod_test_utilities,         only: create_mesh
    use DNAD_D
    
    implicit none
    type(chidg_t)               :: chidg
    type(mesh_t)                :: mesh
    type(point_t),  allocatable :: nodes(:)
    type(domain_connectivity_t) :: connectivity
    type(blockmatrix_t)         :: bmat
    type(AD_D)                  :: integral(8)
    type(face_info_t)           :: face_info
    type(seed_t)                :: seed
    integer(ik)                 :: ielement_l, ivar, nderiv, i, neqns, imat,  &
                                   nterms_c, nterms_s, idomain, spacedim, itime, ntime
    real(rk),   allocatable     :: mat(:,:)
    

    call chidg%start_up('core')


    !
    ! Create (3x3x3) mesh
    !
    call create_mesh('3x3x3',nodes,connectivity)

    
    !
    ! Initialize mesh_t instance.
    !
    neqns    = 1
    idomain  = 1
    spacedim = 3
    nterms_c = 8
    nterms_s = 8
    ntime    = 1
    call mesh%init_geom(idomain,spacedim,nterms_c,nodes,connectivity)
    call mesh%init_sol(neqns,nterms_s,ntime)
    call mesh%init_comm_local()




    !
    ! Call initialization on block matrix
    !
    call bmat%init(mesh,mtype='full')



    nderiv = neqns*nterms_s
    !
    ! Initialize AD variables with allocated derivative arrays
    !
    do i = 1,8
        integral(i) = AD_D(nderiv)
    end do


    



    integral = [ONE, TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT]
    !
    ! Set the first and last element of each derivative array so they aren't just zeros
    !
    integral(1)%xp_ad_(1) = ONE
    integral(1)%xp_ad_(8) = ONE
    
    integral(2)%xp_ad_(1) = TWO
    integral(2)%xp_ad_(8) = TWO
    
    integral(3)%xp_ad_(1) = THREE
    integral(3)%xp_ad_(8) = THREE
    
    integral(4)%xp_ad_(1) = FOUR
    integral(4)%xp_ad_(8) = FOUR
    
    integral(5)%xp_ad_(1) = FIVE
    integral(5)%xp_ad_(8) = FIVE
    
    integral(6)%xp_ad_(1) = SIX
    integral(6)%xp_ad_(8) = SIX
    
    integral(7)%xp_ad_(1) = SEVEN
    integral(7)%xp_ad_(8) = SEVEN
    
    integral(8)%xp_ad_(1) = EIGHT
    integral(8)%xp_ad_(8) = EIGHT




    !
    ! PROCEDURE BEING TESTED, bmat%store
    !
    ielement_l = 14
    ivar       = 1
    itime      = 1
    call face_info%init(idomain_g=1,idomain_l=1,ielement_g=14,ielement_l=14,iface=0)
    call seed%init(     idomain_g=1,idomain_l=1,ielement_g=13,ielement_l=13,iproc=0)

    call bmat%store(integral,face_info,seed,ivar,itime)


    !
    ! Check that the derivatives were assigned to their correct locations in the block matrix.
    ! The xp_ad_ arrays should be stored as rows of the block matrix.
    !
    imat = bmat%lblks(ielement_l,itime)%find(idomain_g=1,ielement_g=13)
    mat  = bmat%lblks(ielement_l,itime)%dmat(imat)
    @assertEqual(integral(1)%xp_ad_, mat(1,:) )
    @assertEqual(integral(2)%xp_ad_, mat(2,:) )
    @assertEqual(integral(3)%xp_ad_, mat(3,:) )
    @assertEqual(integral(4)%xp_ad_, mat(4,:) )
    @assertEqual(integral(5)%xp_ad_, mat(5,:) )
    @assertEqual(integral(6)%xp_ad_, mat(6,:) )
    @assertEqual(integral(7)%xp_ad_, mat(7,:) )
    @assertEqual(integral(8)%xp_ad_, mat(8,:) )
        
    

    !
    ! Close ChiDG interface
    !
    call chidg%shut_down('core')

end subroutine test_blockmatrix__store_1eq_8terms








! Test storage of derivatives to blockmatrix when using 2 equations
@Test
subroutine test_blockmatrix__store_2eq_8terms()
    use pfunit_mod
    use mod_kinds,                  only: rk,ik
    use mod_constants,              only: ONE, TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT
    use type_chidg,                 only: chidg_t
    use type_mesh,                  only: mesh_t
    use type_point,                 only: point_t
    use type_blockmatrix,           only: blockmatrix_t
    use type_domain_connectivity,   only: domain_connectivity_t
    use type_face_info,             only: face_info_t
    use type_seed,                  only: seed_t
    use mod_test_utilities,         only: create_mesh
    use DNAD_D
    
    implicit none
    type(chidg_t)               :: chidg
    type(mesh_t)                :: mesh    
    type(point_t),  allocatable :: nodes(:)
    type(domain_connectivity_t) :: connectivity
    type(blockmatrix_t)         :: bmat
    type(face_info_t)           :: face_info
    type(seed_t)                :: seed
    type(AD_D)                  :: integral(8)
    integer(ik)                 :: ivar, nderiv, i, neqns, imat, idomain, ielem, &
                                   nterms_c, nterms_s, spacedim, itime, ntime
    real(rk),   allocatable     :: mat(:,:)
    
    call chidg%start_up('core')
    

    !
    ! Create 3x3x3 mesh
    !
    call create_mesh('3x3x3',nodes,connectivity)


    !
    ! Initialize mesh_t instance.
    !
    neqns    = 2
    idomain  = 1
    spacedim = 3
    nterms_c = 8
    nterms_s = 8
    ntime    = 1
    call mesh%init_geom(idomain,spacedim,nterms_c,nodes,connectivity)
    call mesh%init_sol(neqns,nterms_s,ntime)
    call mesh%init_comm_local()


    !
    ! Call initialization on block matrix
    !
    call bmat%init(mesh,mtype='full')


    !
    ! Initialize AD variables with allocated derivative arrays
    !
    nderiv = neqns*nterms_s
    do i = 1,8
        integral(i) = AD_D(nderiv)
    end do



    !
    ! Set the first and last element of each derivative array so they aren't just zeros
    !
    integral = [ONE, TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT]

    integral(1)%xp_ad_(1) = ONE
    integral(1)%xp_ad_(8) = ONE
    
    integral(2)%xp_ad_(1) = TWO
    integral(2)%xp_ad_(8) = TWO
    
    integral(3)%xp_ad_(1) = THREE
    integral(3)%xp_ad_(8) = THREE
    
    integral(4)%xp_ad_(1) = FOUR
    integral(4)%xp_ad_(8) = FOUR
    
    integral(5)%xp_ad_(1) = FIVE
    integral(5)%xp_ad_(8) = FIVE
    
    integral(6)%xp_ad_(1) = SIX
    integral(6)%xp_ad_(8) = SIX
    
    integral(7)%xp_ad_(1) = SEVEN
    integral(7)%xp_ad_(8) = SEVEN
    
    integral(8)%xp_ad_(1) = EIGHT
    integral(8)%xp_ad_(8) = EIGHT



    !
    ! PROCEDURE BEING TESTED, bmat%store
    !
    call face_info%init(idomain_g=1,idomain_l=1,ielement_g=14,ielement_l=14,iface=0)
    call seed%init(idomain_g=1,idomain_l=1,ielement_g=13,ielement_l=13,iproc=0)

    ielem = 14
    itime = 1
    ivar  = 2
    call bmat%store(integral,face_info,seed,ivar,itime)


    !
    ! Check that the derivatives were assigned to their correct locations in the block matrix.
    ! The xp_ad_ arrays should be stored as rows of the block matrix.
    !
    imat = bmat%lblks(ielem,itime)%find(idomain_g=1,ielement_g=13)
    mat  = bmat%lblks(ielem,itime)%dmat(imat)
    @assertEqual(integral(1)%xp_ad_, mat(9,:) )
    @assertEqual(integral(2)%xp_ad_, mat(10,:) )
    @assertEqual(integral(3)%xp_ad_, mat(11,:) )
    @assertEqual(integral(4)%xp_ad_, mat(12,:) )
    @assertEqual(integral(5)%xp_ad_, mat(13,:) )
    @assertEqual(integral(6)%xp_ad_, mat(14,:) )
    @assertEqual(integral(7)%xp_ad_, mat(15,:) )
    @assertEqual(integral(8)%xp_ad_, mat(16,:) )
        
    
    !
    ! Close ChiDG interface
    !
    call chidg%shut_down('core')


end subroutine test_blockmatrix__store_2eq_8terms










!
! Test that blockmatrix data is getting zeroed
!
@Test
subroutine test_blockmatrix__clear_1eq_8terms()
    use pfunit_mod
    use mod_kinds,                  only: rk,ik
    use mod_constants,              only: ZERO, ONE, TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT
    use type_chidg,                 only: chidg_t
    use type_mesh,                  only: mesh_t
    use type_point,                 only: point_t
    use type_blockmatrix,           only: blockmatrix_t
    use type_domain_connectivity,   only: domain_connectivity_t
    use type_face_info,             only: face_info_t
    use type_seed,                  only: seed_t
    use mod_test_utilities,         only: create_mesh
    use DNAD_D
    
    implicit none
    type(chidg_t)               :: chidg
    type(mesh_t)                :: mesh    
    type(point_t),  allocatable :: nodes(:)
    type(domain_connectivity_t) :: connectivity
    type(blockmatrix_t)         :: bmat
    type(AD_D)                  :: integral(8)
    type(face_info_t)           :: face_info
    type(seed_t)                :: seed
    integer(ik)                 :: ielement_l, ivar, nderiv, i, neqns, imat, ielem, &
                                   nterms_c, nterms_s, idomain, spacedim, ntime, itime
    real(rk)                    :: tol
    real(rk),   allocatable     :: mat(:,:)

    tol = 1.e-16_rk
    
    call chidg%start_up('core')
    


    !
    ! Create a 3x3x3 mesh
    !
    call create_mesh('3x3x3',nodes,connectivity)



    !
    ! Initialize a mesh_t instance.
    !
    neqns    = 1
    idomain  = 1
    spacedim = 3
    nterms_c = 8
    nterms_s = 8
    ntime    = 1
    call mesh%init_geom(idomain,spacedim,nterms_c,nodes,connectivity)
    call mesh%init_sol(neqns,nterms_s,ntime)                              
    call mesh%init_comm_local()



    !
    ! Call initialization on block matrix
    !
    call bmat%init(mesh,mtype='full')



    !
    ! Initialize AD variables with allocated derivative arrays
    !
    nderiv = neqns*nterms_s
    do i = 1,8
        integral(i) = AD_D(nderiv)
    end do



    integral = [ONE, TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT]
    !
    ! Set the first and last element of each derivative array so they aren't just zeros
    !
    integral(1)%xp_ad_(1) = ONE
    integral(1)%xp_ad_(8) = ONE
    
    integral(2)%xp_ad_(1) = TWO
    integral(2)%xp_ad_(8) = TWO
    
    integral(3)%xp_ad_(1) = THREE
    integral(3)%xp_ad_(8) = THREE
    
    integral(4)%xp_ad_(1) = FOUR
    integral(4)%xp_ad_(8) = FOUR
    
    integral(5)%xp_ad_(1) = FIVE
    integral(5)%xp_ad_(8) = FIVE
    
    integral(6)%xp_ad_(1) = SIX
    integral(6)%xp_ad_(8) = SIX
    
    integral(7)%xp_ad_(1) = SEVEN
    integral(7)%xp_ad_(8) = SEVEN
    
    integral(8)%xp_ad_(1) = EIGHT
    integral(8)%xp_ad_(8) = EIGHT


    !
    ! Store Derivatives
    !
    call face_info%init(idomain_g=1,idomain_l=1,ielement_g=14,ielement_l=14,iface=0)
    call seed%init(     idomain_g=1,idomain_l=1,ielement_g=13,ielement_l=13,iproc=0)
    ivar  = 1
    itime = 1
    call bmat%store(integral,face_info,seed,ivar,itime)



    !
    ! TESTING THIS
    !
    call bmat%clear()
    

    
    !
    ! Loop through all blocks and assert ZERO
    !
    do ielem = 1,27
        do imat = 1,bmat%lblks(ielem,itime)%size()
            @assertEqual(ZERO, bmat%lblks(ielem,itime)%dmat(imat), tol)
        end do
    end do



    !
    ! Close ChiDG interface
    !
    call chidg%shut_down('core')
    
end subroutine





















    
